// src/hooks/editor/useContactForm.ts
// Contact form logic hook (Layer 2) - manages contact info and social links

import { useState, useRef, useEffect, useCallback, Dispatch, SetStateAction } from 'react';
import { ContactInfo, SocialLink } from '../../types';
import { UseContactFormReturn } from '../../types/editor';
import {
  validatePlatformUrl,
  generateDisplayText,
} from '../../constants/socialPlatforms';
import { validateLinkedInUrl } from '../../services/validationService';

/**
 * Props for useContactForm hook (dependency injection from Layer 1)
 */
export interface UseContactFormProps {
  contactInfo: ContactInfo | null;
  setContactInfo: Dispatch<SetStateAction<ContactInfo | null>>;
}

/**
 * useContactForm Hook
 *
 * Manages contact form logic including:
 * - Contact info field updates
 * - Social link CRUD operations
 * - Social link validation with 500ms debounce
 * - Auto-generated display text from URLs
 * - Cleanup of debounce timers
 *
 * @param props - Dependency injection props from useEditorState
 * @returns Contact form operations and state
 *
 * @example
 * const contactForm = useContactForm({ contactInfo, setContactInfo });
 * contactForm.updateContactField('name', 'John Doe');
 * contactForm.handleAddSocialLink();
 */
export const useContactForm = ({
  contactInfo: _contactInfo, // Unused - we read state via functional updaters to avoid stale closures
  setContactInfo,
}: UseContactFormProps): UseContactFormReturn => {
  // Social link validation errors (index -> error message)
  const [socialLinkErrors, setSocialLinkErrors] = useState<
    Record<number, string>
  >({});

  // Track which social links have auto-generated display text
  const [autoGeneratedIndexes, setAutoGeneratedIndexes] = useState<Set<number>>(
    new Set()
  );

  // Debounce timers for social link validation/auto-generation
  const socialLinkDebounceRefs = useRef<Record<number, NodeJS.Timeout>>({});

  /**
   * Cleanup all debounce timers on unmount
   */
  useEffect(() => {
    return () => {
      Object.values(socialLinkDebounceRefs.current).forEach((timer) =>
        clearTimeout(timer)
      );
      socialLinkDebounceRefs.current = {};
    };
  }, []);

  /**
   * Updates a specific ContactInfo field
   * Type-safe helper for updating contact info properties
   *
   * @param field - ContactInfo field name
   * @param value - New value for the field
   */
  const updateContactField = useCallback(
    <K extends keyof ContactInfo>(field: K, value: ContactInfo[K]) => {
      setContactInfo((prev) => {
        if (!prev) return null;
        return { ...prev, [field]: value };
      });
    },
    [setContactInfo]
  );

  /**
   * Validates LinkedIn URL
   * Re-exported from validationService for convenience
   *
   * @param url - LinkedIn URL to validate
   * @returns true if valid or empty, false if invalid
   */
  const validateLinkedIn = useCallback(
    (url: string): boolean => {
      return validateLinkedInUrl(url);
    },
    []
  );

  /**
   * Adds a new empty social link
   */
  const handleAddSocialLink = useCallback(() => {
    setContactInfo((prev) => {
      if (!prev) return null;

      const currentLinks = prev.social_links || [];
      return {
        ...prev,
        social_links: [
          ...currentLinks,
          { platform: '', url: '', display_text: '' },
        ],
      };
    });
  }, [setContactInfo]);

  /**
   * Removes a social link by index
   * Also clears associated errors, auto-generated flags, and debounce timers
   *
   * @param index - Index of social link to remove
   */
  const handleRemoveSocialLink = useCallback(
    (index: number) => {
      setContactInfo((prev) => {
        if (!prev) return null;

        const currentLinks = prev.social_links || [];
        const updatedLinks = currentLinks.filter((_: SocialLink, i: number) => i !== index);

        return {
          ...prev,
          social_links: updatedLinks,
        };
      });

      // Remap error indices - items before removed index stay, items after shift down
      setSocialLinkErrors((prev) => {
        const updated: Record<number, string> = {};
        Object.keys(prev).forEach((key) => {
          const i = parseInt(key, 10);
          if (i < index) {
            // Keep items before removed index
            updated[i] = prev[i];
          } else if (i > index) {
            // Shift down items after removed index
            updated[i - 1] = prev[i];
          }
          // Skip i === index (it gets deleted)
        });
        return updated;
      });

      // Remap auto-generated indices - same logic as errors
      setAutoGeneratedIndexes((prev) => {
        const updated = new Set<number>();
        prev.forEach((i) => {
          if (i < index) {
            updated.add(i);
          } else if (i > index) {
            updated.add(i - 1);
          }
          // Skip i === index (it gets deleted)
        });
        return updated;
      });

      // Remap debounce refs - same logic as errors
      if (socialLinkDebounceRefs.current[index]) {
        clearTimeout(socialLinkDebounceRefs.current[index]);
      }
      const newDebounceRefs: Record<number, NodeJS.Timeout> = {};
      Object.keys(socialLinkDebounceRefs.current).forEach((key) => {
        const i = parseInt(key, 10);
        if (i < index) {
          newDebounceRefs[i] = socialLinkDebounceRefs.current[i];
        } else if (i > index) {
          newDebounceRefs[i - 1] = socialLinkDebounceRefs.current[i];
        }
        // Skip i === index (it gets deleted)
      });
      socialLinkDebounceRefs.current = newDebounceRefs;
    },
    [setContactInfo]
  );

  /**
   * Debounced helper to generate social link display text
   * Internal function - not exposed in return type
   *
   * Reads contactInfo.name from state updater to avoid stale closures
   *
   * @param index - Social link index
   * @param platform - Platform ID
   * @param url - Profile URL
   */
  const debouncedGenerateSocialDisplayText = useCallback(
    (index: number, platform: string, url: string) => {
      // Clear existing timeout for this index
      if (socialLinkDebounceRefs.current[index]) {
        clearTimeout(socialLinkDebounceRefs.current[index]);
      }

      // Set new timeout for 500ms debounce
      socialLinkDebounceRefs.current[index] = setTimeout(() => {
        setContactInfo((prev) => {
          if (!prev) return null;

          // Read prev.name here to get the latest value from state
          // This prevents stale closures if name changes during debounce
          const displayText = generateDisplayText(platform, url, prev.name);

          const currentLinks = prev.social_links || [];
          const updatedLinks = [...currentLinks];

          if (updatedLinks[index]) {
            updatedLinks[index] = {
              ...updatedLinks[index],
              display_text: displayText,
            };
          }

          return {
            ...prev,
            social_links: updatedLinks,
          };
        });

        // Mark this index as auto-generated
        setAutoGeneratedIndexes((prev) => new Set(prev).add(index));
      }, 500);
    },
    [setContactInfo]
  );

  /**
   * Helper to validate URL and handle errors/auto-generation
   * Extracted to reduce duplication between URL and platform changes
   *
   * @param index - Social link index
   * @param platform - Platform ID
   * @param url - Profile URL
   */
  const validateAndAutoGenerate = useCallback(
    (index: number, platform: string, url: string) => {
      const validation = validatePlatformUrl(platform, url);

      if (!validation.valid && validation.error) {
        setSocialLinkErrors((prev) => ({
          ...prev,
          [index]: validation.error || '',
        }));
      } else {
        setSocialLinkErrors((prev) => {
          const updated = { ...prev };
          delete updated[index];
          return updated;
        });
        debouncedGenerateSocialDisplayText(index, platform, url);
      }
    },
    [debouncedGenerateSocialDisplayText]
  );

  /**
   * Handles changes to a social link field
   * Validates URLs, auto-generates display text, manages errors
   *
   * Uses functional updater to read current state, avoiding stale closures
   * and preventing re-creation on every contactInfo change.
   *
   * @param index - Social link index
   * @param field - Field name (platform, url, display_text)
   * @param value - New value
   */
  const handleSocialLinkChange = useCallback(
    (index: number, field: keyof SocialLink, value: string) => {
      // Track computed values needed for side effects (set by the updater)
      let computedPlatform = '';
      let computedUrl = '';
      let shouldClearError = false;
      let shouldValidate = false;
      let shouldClearAutoGen = false;

      // Use functional updater to read current state atomically
      // This prevents stale closures when called in quick succession
      setContactInfo((prev) => {
        if (!prev) return null;

        // Get current link from the latest state
        const currentLink = prev.social_links?.[index] || {
          platform: '',
          url: '',
          display_text: '',
        };

        // Compute the new link by applying the change
        const newLink = { ...currentLink, [field]: value };

        // Determine side effects based on field changes
        if (field === 'url') {
          if (!value.trim()) {
            // URL is cleared, so clear display text
            newLink.display_text = '';
            shouldClearError = true;
            shouldClearAutoGen = true;
          } else if (newLink.platform) {
            // URL has a value with platform, validate and auto-generate
            computedPlatform = newLink.platform;
            computedUrl = value;
            shouldValidate = true;
          }
        } else if (field === 'platform') {
          // Platform changed, re-validate if URL exists
          if (newLink.url && value) {
            computedPlatform = value;
            computedUrl = newLink.url;
            shouldValidate = true;
          }
        } else if (field === 'display_text') {
          // Manual edit, clear auto-gen flag
          shouldClearAutoGen = true;
        }

        // Return updated state
        const updatedLinks = [...(prev.social_links || [])];
        updatedLinks[index] = newLink;
        return { ...prev, social_links: updatedLinks };
      });

      // Execute side effects after state update (synchronously)
      // These use their own updater functions so they're safe from stale closures
      if (shouldClearError) {
        setSocialLinkErrors((prevErrors) => {
          const updated = { ...prevErrors };
          delete updated[index];
          return updated;
        });
      }

      if (shouldClearAutoGen) {
        setAutoGeneratedIndexes((prevIndexes) => {
          const updated = new Set(prevIndexes);
          updated.delete(index);
          return updated;
        });
      }

      if (shouldValidate) {
        validateAndAutoGenerate(index, computedPlatform, computedUrl);
      }
    },
    [setContactInfo, validateAndAutoGenerate]
  );

  return {
    // Contact info operations
    updateContactField,
    validateLinkedIn,

    // Social links operations
    socialLinkErrors,
    autoGeneratedIndexes,
    handleAddSocialLink,
    handleRemoveSocialLink,
    handleSocialLinkChange,
  };
};
