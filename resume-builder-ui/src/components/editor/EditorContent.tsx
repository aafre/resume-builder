// src/components/editor/EditorContent.tsx
// Main content area for the Editor, including sections, drag-drop, toolbars

import React, { RefObject } from 'react';
import { AlertCircle, X } from 'lucide-react';
import {
  DndContext,
  closestCenter,
  DragOverlay,
  DragStartEvent,
  DragEndEvent,
  SensorDescriptor,
  SensorOptions,
} from '@dnd-kit/core';
import {
  SortableContext,
  verticalListSortingStrategy,
} from '@dnd-kit/sortable';
import {
  restrictToVerticalAxis,
  restrictToWindowEdges,
} from '@dnd-kit/modifiers';

import { ContactInfo, Section, SaveStatus, IconListItem } from '../../types';
import { isExperienceSection, isEducationSection } from '../../utils/sectionTypeChecker';
import ContactInfoSection from '../ContactInfoSection';
import FormattingHelp from '../FormattingHelp';
import ExperienceSection from '../ExperienceSection';
import EducationSection from '../EducationSection';
import GenericSection from '../GenericSection';
import IconListSection from '../IconListSection';
import EditorToolbar from '../EditorToolbar';
import MobileActionBar from '../MobileActionBar';
import MobileNavigationDrawer from '../MobileNavigationDrawer';
import SectionNavigator from '../SectionNavigator';
import DragHandle from '../DragHandle';

/**
 * Props for contact form functionality
 */
export interface EditorContentContactFormProps {
  socialLinkErrors: Record<number, string>;
  autoGeneratedIndexes: Set<number>;
  handleSocialLinkChange: (index: number, field: 'platform' | 'url' | 'display_text', value: string) => void;
  handleAddSocialLink: () => void;
  handleRemoveSocialLink: (index: number) => void;
}

/**
 * Props for drag and drop functionality
 */
export interface EditorContentDragDropProps {
  sensors: SensorDescriptor<SensorOptions>[];
  activeId: string | null;
  draggedSection: Section | null;
  handleDragStart: (event: DragStartEvent) => void;
  handleDragEnd: (event: DragEndEvent) => void;
  handleDragCancel: () => void;
}

/**
 * Props for section management functionality
 */
export interface EditorContentSectionManagementProps {
  editingTitleIndex: number | null;
  temporaryTitle: string;
  setTemporaryTitle: React.Dispatch<React.SetStateAction<string>>;
  handleUpdateSection: (index: number, updatedSection: Section) => void;
  handleDeleteSection: (index: number) => void;
  handleDeleteEntry: (sectionIndex: number, entryIndex: number) => void;
  handleReorderEntry: (sectionIndex: number, oldIndex: number, newIndex: number) => void;
  handleTitleEdit: (index: number) => void;
  handleTitleSave: () => void;
  handleTitleCancel: () => void;
}

/**
 * Props for navigation functionality
 */
export interface EditorContentNavigationProps {
  activeSectionIndex: number;
  isSidebarCollapsed: boolean;
  scrollToSection: (sectionIndex: number) => void;
  setIsSidebarCollapsed: (collapsed: boolean) => void;
}

/**
 * Props for modal manager (subset needed by EditorContent)
 */
export interface EditorContentModalProps {
  showAIWarning: boolean;
  showAdvancedMenu: boolean;
  showNavigationDrawer: boolean;
  closeAIWarning: () => void;
  openAdvancedMenu: () => void;
  closeAdvancedMenu: () => void;
  openNavigationDrawer: () => void;
  closeNavigationDrawer: () => void;
  openSectionTypeModal: () => void;
  openHelpModal: () => void;
}

/**
 * Props for file operations (subset needed by EditorContent)
 */
export interface EditorContentFileOperationsProps {
  handleExportYAML: () => Promise<void>;
  handleFileInputChange: (event: React.ChangeEvent<HTMLInputElement>) => void;
  fileInputRef: RefObject<HTMLInputElement>;
  loadingSave: boolean;
  loadingLoad: boolean;
}

/**
 * Props for editor actions (subset needed by EditorContent)
 */
export interface EditorContentEditorActionsProps {
  handleGenerateResume: () => Promise<void>;
  handleOpenPreview: () => Promise<void>;
  handleStartFresh: () => void;
  isDownloading: boolean;
}

/**
 * Props for preview state
 */
export interface EditorContentPreviewProps {
  isGenerating: boolean;
  isStale: boolean;
}

/**
 * Props for save status
 */
export interface EditorContentSaveStatusProps {
  saveStatus: SaveStatus;
  lastSaved: Date | null;
}

/**
 * Icon registry interface (subset of useIconRegistry return)
 */
export interface EditorContentIconRegistry {
  registerIcon: (file: File) => string;
  registerIconWithFilename: (file: File, filename: string) => void;
  getIconFile: (filename: string) => File | null;
  removeIcon: (filename: string) => void;
  clearRegistry: () => void;
  getRegisteredFilenames: () => string[];
  getRegistrySize: () => number;
}

/**
 * Props for reorder mode functionality
 */
export interface EditorContentReorderModeProps {
  isReorderModeActive: boolean;
  hasUnsavedReorderChanges: boolean;
  enterReorderMode: () => void;
  cancelReorderMode: () => void;
  commitReorderMode: () => void;
  moveSectionUp: (index: number) => void;
  moveSectionDown: (index: number) => void;
  canMoveUp: (index: number) => boolean;
  canMoveDown: (index: number, total: number) => boolean;
}

/**
 * Ref objects for scroll handling
 */
export interface EditorContentRefs {
  contactInfoRef: RefObject<HTMLDivElement>;
  sectionRefs: React.MutableRefObject<(HTMLDivElement | null)[]>;
  newSectionRef: React.MutableRefObject<HTMLDivElement | null>;
}

/**
 * Main props for EditorContent component
 */
export interface EditorContentProps {
  // Core data
  contactInfo: ContactInfo | null;
  setContactInfo: React.Dispatch<React.SetStateAction<ContactInfo | null>>;
  sections: Section[];
  supportsIcons: boolean;
  iconRegistry: EditorContentIconRegistry;

  // Auth state
  isAnonymous: boolean;
  isAuthenticated: boolean;

  // Grouped props
  contactForm: EditorContentContactFormProps;
  dragDrop: EditorContentDragDropProps;
  sectionManagement: EditorContentSectionManagementProps;
  navigation: EditorContentNavigationProps;
  reorderMode?: EditorContentReorderModeProps;
  modals: EditorContentModalProps;
  fileOperations: EditorContentFileOperationsProps;
  editorActions: EditorContentEditorActionsProps;
  preview: EditorContentPreviewProps;
  saveStatus: EditorContentSaveStatusProps;
  refs: EditorContentRefs;
}

/**
 * EditorContent Component
 *
 * Main content area for the Editor, including:
 * - AI Warning banner
 * - Contact Information Section
 * - Formatting Help
 * - Drag-and-drop sections with DndContext
 * - Section rendering loop (Experience, Education, IconList, Generic)
 * - DragOverlay for drag preview
 * - Desktop Toolbar (tablet)
 * - Mobile Action Bar
 * - Mobile Navigation Drawer
 * - Desktop Section Navigator Sidebar
 * - Hidden file input
 *
 * @example
 * <EditorContent
 *   contactInfo={contactInfo}
 *   setContactInfo={setContactInfo}
 *   sections={sections}
 *   supportsIcons={supportsIcons}
 *   iconRegistry={iconRegistry}
 *   contactForm={contactForm}
 *   dragDrop={dragDrop}
 *   sectionManagement={sectionManagement}
 *   navigation={navigation}
 *   modals={modals}
 *   fileOperations={fileOperations}
 *   editorActions={editorActions}
 *   preview={preview}
 *   saveStatus={saveStatus}
 *   refs={refs}
 * />
 */
export const EditorContent: React.FC<EditorContentProps> = ({
  contactInfo,
  setContactInfo,
  sections,
  supportsIcons,
  iconRegistry,
  isAnonymous,
  isAuthenticated,
  contactForm,
  dragDrop,
  sectionManagement,
  navigation,
  reorderMode,
  modals,
  fileOperations,
  editorActions,
  preview,
  saveStatus,
  refs,
}) => {
  // Handler for adding new section
  const handleAddNewSectionClick = () => {
    modals.openSectionTypeModal();
  };

  return (
    <div
      className={`mx-auto px-4 sm:px-6 lg:px-8 pt-6 pb-[calc(var(--mobile-action-bar-height)+1rem)] lg:pb-[1rem] max-w-4xl lg:max-w-none transition-all duration-300 ${
        navigation.isSidebarCollapsed ? 'lg:mr-[88px]' : 'lg:mr-[296px]'
      }`}
    >
      {/* Imported Resume Review Banner */}
      {modals.showAIWarning && (
        <div className="mb-4 p-4 rounded-lg border-2 bg-blue-50 border-blue-200 flex items-start gap-3">
          <AlertCircle className="w-5 h-5 flex-shrink-0 mt-0.5 text-blue-600" />
          <div className="flex-1">
            <h3 className="font-semibold text-sm text-blue-900">
              Imported Resume - Please Review
            </h3>
            <p className="text-xs mt-1 text-blue-700">
              Please review all information for accuracy and completeness.
            </p>
          </div>
          <button
            onClick={modals.closeAIWarning}
            className="text-gray-400 hover:text-gray-600"
            aria-label="Close review banner"
          >
            <X className="w-4 h-4" />
          </button>
        </div>
      )}

      {/* Contact Information Section */}
      {contactInfo && (
        <div ref={refs.contactInfoRef}>
          <ContactInfoSection
            contactInfo={contactInfo}
            onUpdate={setContactInfo}
            socialLinkErrors={contactForm.socialLinkErrors}
            onSocialLinkChange={contactForm.handleSocialLinkChange}
            onAddSocialLink={contactForm.handleAddSocialLink}
            onRemoveSocialLink={contactForm.handleRemoveSocialLink}
            autoGeneratedIndexes={contactForm.autoGeneratedIndexes}
          />
        </div>
      )}

      {/* Global Formatting Help */}
      <FormattingHelp />

      {/* Resume Sections with Drag and Drop */}
      <DndContext
        sensors={dragDrop.sensors}
        collisionDetection={closestCenter}
        onDragStart={dragDrop.handleDragStart}
        onDragEnd={dragDrop.handleDragEnd}
        onDragCancel={dragDrop.handleDragCancel}
        modifiers={[restrictToVerticalAxis, restrictToWindowEdges]}
      >
        <SortableContext
          items={sections.map((_, index) => `section-${index}`)}
          strategy={verticalListSortingStrategy}
        >
          {sections.map((section, index) => {
            if (isExperienceSection(section)) {
              return (
                <DragHandle key={index} id={`section-${index}`} disabled={false}>
                  <div
                    ref={(el) => {
                      refs.sectionRefs.current[index] = el;
                      if (index === sections.length - 1) {
                        refs.newSectionRef.current = el;
                      }
                    }}
                  >
                    <ExperienceSection
                      sectionName={section.name}
                      experiences={section.content}
                      onUpdate={(updatedExperiences) =>
                        sectionManagement.handleUpdateSection(index, {
                          ...section,
                          content: updatedExperiences,
                        } as Section)
                      }
                      onTitleEdit={() => sectionManagement.handleTitleEdit(index)}
                      onTitleSave={sectionManagement.handleTitleSave}
                      onTitleCancel={sectionManagement.handleTitleCancel}
                      onDelete={() => sectionManagement.handleDeleteSection(index)}
                      onDeleteEntry={(entryIndex) =>
                        sectionManagement.handleDeleteEntry(index, entryIndex)
                      }
                      onReorderEntry={(oldIndex, newIndex) =>
                        sectionManagement.handleReorderEntry(index, oldIndex, newIndex)
                      }
                      isEditingTitle={sectionManagement.editingTitleIndex === index}
                      temporaryTitle={sectionManagement.temporaryTitle}
                      setTemporaryTitle={sectionManagement.setTemporaryTitle}
                      supportsIcons={supportsIcons}
                      iconRegistry={iconRegistry}
                    />
                  </div>
                </DragHandle>
              );
            } else if (isEducationSection(section)) {
              return (
                <DragHandle key={index} id={`section-${index}`} disabled={false}>
                  <div
                    ref={(el) => {
                      refs.sectionRefs.current[index] = el;
                      if (index === sections.length - 1) {
                        refs.newSectionRef.current = el;
                      }
                    }}
                  >
                    <EducationSection
                      sectionName={section.name}
                      education={section.content}
                      onUpdate={(updatedEducation) =>
                        sectionManagement.handleUpdateSection(index, {
                          ...section,
                          content: updatedEducation,
                        } as Section)
                      }
                      onTitleEdit={() => sectionManagement.handleTitleEdit(index)}
                      onTitleSave={sectionManagement.handleTitleSave}
                      onTitleCancel={sectionManagement.handleTitleCancel}
                      onDelete={() => sectionManagement.handleDeleteSection(index)}
                      onDeleteEntry={(entryIndex) =>
                        sectionManagement.handleDeleteEntry(index, entryIndex)
                      }
                      onReorderEntry={(oldIndex, newIndex) =>
                        sectionManagement.handleReorderEntry(index, oldIndex, newIndex)
                      }
                      isEditingTitle={sectionManagement.editingTitleIndex === index}
                      temporaryTitle={sectionManagement.temporaryTitle}
                      setTemporaryTitle={sectionManagement.setTemporaryTitle}
                      supportsIcons={supportsIcons}
                      iconRegistry={iconRegistry}
                    />
                  </div>
                </DragHandle>
              );
            } else if (section.type === 'icon-list') {
              return (
                <DragHandle key={index} id={`section-${index}`} disabled={false}>
                  <div
                    ref={(el) => {
                      refs.sectionRefs.current[index] = el;
                      if (index === sections.length - 1) {
                        refs.newSectionRef.current = el;
                      }
                    }}
                  >
                    <IconListSection
                      data={section.content as IconListItem[]}
                      onUpdate={(updatedContent) =>
                        sectionManagement.handleUpdateSection(index, {
                          ...section,
                          content: updatedContent,
                        } as Section)
                      }
                      onDelete={() => sectionManagement.handleDeleteSection(index)}
                      onDeleteEntry={(entryIndex) =>
                        sectionManagement.handleDeleteEntry(index, entryIndex)
                      }
                      onReorderEntry={(oldIndex, newIndex) =>
                        sectionManagement.handleReorderEntry(index, oldIndex, newIndex)
                      }
                      sectionName={section.name}
                      onEditTitle={() => sectionManagement.handleTitleEdit(index)}
                      onSaveTitle={sectionManagement.handleTitleSave}
                      onCancelTitle={sectionManagement.handleTitleCancel}
                      isEditing={sectionManagement.editingTitleIndex === index}
                      temporaryTitle={sectionManagement.temporaryTitle}
                      setTemporaryTitle={sectionManagement.setTemporaryTitle}
                      iconRegistry={iconRegistry}
                    />
                  </div>
                </DragHandle>
              );
            } else {
              return (
                <DragHandle key={index} id={`section-${index}`} disabled={false}>
                  <div
                    ref={(el) => {
                      refs.sectionRefs.current[index] = el;
                      if (index === sections.length - 1) {
                        refs.newSectionRef.current = el;
                      }
                    }}
                  >
                    <GenericSection
                      section={section}
                      onUpdate={(updatedSection) =>
                        sectionManagement.handleUpdateSection(index, updatedSection)
                      }
                      onEditTitle={() => sectionManagement.handleTitleEdit(index)}
                      onSaveTitle={sectionManagement.handleTitleSave}
                      onCancelTitle={sectionManagement.handleTitleCancel}
                      onDelete={() => sectionManagement.handleDeleteSection(index)}
                      onDeleteEntry={(entryIndex) =>
                        sectionManagement.handleDeleteEntry(index, entryIndex)
                      }
                      onReorderEntry={(oldIndex, newIndex) =>
                        sectionManagement.handleReorderEntry(index, oldIndex, newIndex)
                      }
                      isEditing={sectionManagement.editingTitleIndex === index}
                      temporaryTitle={sectionManagement.temporaryTitle}
                      setTemporaryTitle={sectionManagement.setTemporaryTitle}
                    />
                  </div>
                </DragHandle>
              );
            }
          })}
        </SortableContext>

        <DragOverlay modifiers={[restrictToVerticalAxis]}>
          {dragDrop.activeId && dragDrop.draggedSection ? (
            <div className="drag-overlay">
              {isExperienceSection(dragDrop.draggedSection) ? (
                <ExperienceSection
                  sectionName={dragDrop.draggedSection.name}
                  experiences={dragDrop.draggedSection.content}
                  onUpdate={() => {}}
                  onTitleEdit={() => {}}
                  onTitleSave={() => {}}
                  onTitleCancel={() => {}}
                  onDelete={() => {}}
                  isEditingTitle={false}
                  temporaryTitle=""
                  setTemporaryTitle={() => {}}
                  supportsIcons={supportsIcons}
                  iconRegistry={iconRegistry}
                />
              ) : isEducationSection(dragDrop.draggedSection) ? (
                <EducationSection
                  sectionName={dragDrop.draggedSection.name}
                  education={dragDrop.draggedSection.content}
                  onUpdate={() => {}}
                  onTitleEdit={() => {}}
                  onTitleSave={() => {}}
                  onTitleCancel={() => {}}
                  onDelete={() => {}}
                  isEditingTitle={false}
                  temporaryTitle=""
                  setTemporaryTitle={() => {}}
                  supportsIcons={supportsIcons}
                  iconRegistry={iconRegistry}
                />
              ) : dragDrop.draggedSection.type === 'icon-list' ? (
                <IconListSection
                  data={dragDrop.draggedSection.content as IconListItem[]}
                  onUpdate={() => {}}
                  onDelete={() => {}}
                  sectionName={dragDrop.draggedSection.name}
                  onEditTitle={() => {}}
                  onSaveTitle={() => {}}
                  onCancelTitle={() => {}}
                  isEditing={false}
                  temporaryTitle=""
                  setTemporaryTitle={() => {}}
                  iconRegistry={iconRegistry}
                />
              ) : (
                <GenericSection
                  section={dragDrop.draggedSection}
                  onUpdate={() => {}}
                  onEditTitle={() => {}}
                  onSaveTitle={() => {}}
                  onCancelTitle={() => {}}
                  onDelete={() => {}}
                  isEditing={false}
                  temporaryTitle=""
                  setTemporaryTitle={() => {}}
                />
              )}
            </div>
          ) : null}
        </DragOverlay>
      </DndContext>

      {/* Desktop Toolbar - Tablet only */}
      <div className="hidden md:flex lg:hidden fixed z-[60] bg-gradient-to-r from-slate-50/80 via-blue-50/80 to-indigo-50/80 backdrop-blur-sm shadow-lg transition-all duration-300 left-auto right-6 border border-gray-200/60 rounded-2xl w-auto max-w-none bottom-6">
        <div className="flex items-center justify-between gap-2 sm:gap-4 p-4 lg:p-6 max-w-screen-lg mx-auto lg:max-w-none">
          <EditorToolbar
            onAddSection={handleAddNewSectionClick}
            onGenerateResume={editorActions.handleGenerateResume}
            onExportYAML={fileOperations.handleExportYAML}
            onImportYAML={fileOperations.handleFileInputChange}
            onToggleHelp={modals.openHelpModal}
            onLoadEmptyTemplate={editorActions.handleStartFresh}
            loadingAddSection={false}
            generating={editorActions.isDownloading}
            loadingSave={fileOperations.loadingSave}
            loadingLoad={fileOperations.loadingLoad}
            showAdvancedMenu={modals.showAdvancedMenu}
            setShowAdvancedMenu={(show) =>
              show ? modals.openAdvancedMenu() : modals.closeAdvancedMenu()
            }
            mode="integrated"
          />
        </div>
      </div>

      {/* Mobile Action Bar */}
      <MobileActionBar
        onNavigationClick={modals.openNavigationDrawer}
        onPreviewClick={editorActions.handleOpenPreview}
        onDownloadClick={editorActions.handleGenerateResume}
        isSaving={saveStatus.saveStatus === 'saving'}
        isGenerating={editorActions.isDownloading}
        isGeneratingPreview={preview.isGenerating}
        previewIsStale={preview.isStale}
        lastSaved={saveStatus.lastSaved}
        saveError={saveStatus.saveStatus === 'error'}
      />

      {/* Mobile Navigation Drawer */}
      <MobileNavigationDrawer
        isOpen={modals.showNavigationDrawer}
        onClose={modals.closeNavigationDrawer}
        sections={sections}
        onSectionClick={navigation.scrollToSection}
        activeSectionIndex={navigation.activeSectionIndex}
        onAddSection={handleAddNewSectionClick}
        onExportYAML={fileOperations.handleExportYAML}
        onImportYAML={() => fileOperations.fileInputRef.current?.click()}
        onStartFresh={editorActions.handleStartFresh}
        onHelp={modals.openHelpModal}
        loadingSave={fileOperations.loadingSave}
        loadingLoad={fileOperations.loadingLoad}
      />

      {/* Desktop Section Navigator Sidebar */}
      <SectionNavigator
        sections={sections}
        onSectionClick={navigation.scrollToSection}
        activeSectionIndex={navigation.activeSectionIndex}
        onAddSection={handleAddNewSectionClick}
        onDownloadResume={editorActions.handleGenerateResume}
        onPreviewResume={editorActions.handleOpenPreview}
        onExportYAML={fileOperations.handleExportYAML}
        onImportYAML={() => fileOperations.fileInputRef.current?.click()}
        onStartFresh={editorActions.handleStartFresh}
        onHelp={modals.openHelpModal}
        isGenerating={editorActions.isDownloading}
        isGeneratingPreview={preview.isGenerating}
        previewIsStale={preview.isStale}
        loadingSave={fileOperations.loadingSave}
        loadingLoad={fileOperations.loadingLoad}
        onCollapseChange={navigation.setIsSidebarCollapsed}
        isAnonymous={isAnonymous}
        isAuthenticated={isAuthenticated}
        // Reorder mode props
        isReorderModeActive={reorderMode?.isReorderModeActive}
        hasUnsavedReorderChanges={reorderMode?.hasUnsavedReorderChanges}
        onEnterReorderMode={reorderMode?.enterReorderMode}
        onCancelReorderMode={reorderMode?.cancelReorderMode}
        onCommitReorderMode={reorderMode?.commitReorderMode}
        onMoveSectionUp={reorderMode?.moveSectionUp}
        onMoveSectionDown={reorderMode?.moveSectionDown}
        canMoveUp={reorderMode?.canMoveUp}
        canMoveDown={reorderMode?.canMoveDown}
      />

      {/* Hidden file input */}
      <input
        ref={fileOperations.fileInputRef}
        type="file"
        accept=".yaml,.yml"
        className="hidden"
        onChange={fileOperations.handleFileInputChange}
      />
    </div>
  );
};
